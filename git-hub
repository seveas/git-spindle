#!/usr/bin/env python
#
# Github integration for git.
# Usage: See README
#
# Copyright (C) 2012-2014 Dennis Kaarsemaker <dennis@kaarsemaker.net>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import getpass
import github3
import glob
import docopt
import os
import re
import requests
import shlex
import socket
import sys
import tempfile
import time
import webbrowser
from whelk import Shell
shell = Shell(encoding='utf-8')
PY3 = sys.version_info[0] > 2
if PY3:
    # On python 3, shell decodes into utf-8 as above
    try_decode = lambda x: x
    # On python 3, raw_input has become input
    raw_input = input
else:
    # Try decoding as utf-8 only
    try_decode = lambda x: x.decode('utf-8')

## ANSI color library from github.com/seveas/hacks
class Attr(object):
    def __init__(self, **attr):
        self.attr = attr
        self.rev_attr = dict([(v,k) for k,v in attr.items()])
        for k, v in attr.items():
            setattr(self, k, v)

    def name(self, val):
        return self.rev_attr[val]

    def xterm(self, val):
        return '%d;5;%d' % (self._xterm, val)

fgcolor = Attr(black=30, red=31, green=32, yellow=33, blue=34, magenta=35, cyan=36, white=37, _xterm=38, default=39, none=None)
bgcolor = Attr(black=40, red=41, green=42, yellow=43, blue=44, magenta=45, cyan=46, white=47, _xterm=48, default=49, none=None)
attr    = Attr(normal=0, bright=1, faint=2, underline=4, negative=7, conceal=8, crossed=9, none=None)

esc = '\033'
mode = lambda *args: "%s[%sm" % (esc, ';'.join([str(x) for x in args if x is not None]))
reset = mode(attr.normal)
if sys.stdout.isatty():
    wrap = lambda text, *args: "%s%s%s" % (mode(*args), text, reset)
else:
    wrap = lambda text, *args: text

erase_line = esc + '[K'
erase_display = esc + '[2J'
save_cursor = esc + '[s'
restore_cursor = esc + '[u'
## End ansi color library

# Make gists behave more like repos
import github3.gists
github3.gists.Gist.ssh_url = property(lambda self: 'git@gist.github.com:/%s.git' % self.id)
github3.gists.Gist.clone_url = property(lambda self: self.git_pull_url)
github3.gists.Gist.git_url = property(lambda self: 'git://gist.github.com/%s.git' % self.id)
github3.gists.Gist.name = property(lambda self: self.id)
github3.gists.Gist.private = property(lambda self: not self.public)
github3.gists.Gist.create_fork = github3.gists.Gist.fork
# XXX - There is nothing in the API output that indicates forkedness
github3.gists.Gist.fork = False
github3.gists.Gist.iter_issues = lambda self, *args, **kwargs: []
def _iter_gist_events(self, number=300):
    for event in self.history[:number]:
        yield GistEvent(event, self)
class GistEvent(object):
    type = 'GistHistoryEvent'
    def __init__(self, history, gist):
        self.created_at = history.committed_at
        self.additions = history.additions
        self.deletions = history.deletions
        self.actor = history.user
        if not self.actor.login:
            self.actor = gist.owner
        self.repo = ('gist', gist.name)
github3.gists.Gist.iter_events = _iter_gist_events
class Content(object):
    def __init__(self, file):
        self.decoded = file.content
def _gist_contents(self, path, ref):
    # XXX ignore ref for now, can't do much with it
    for f in self.iter_files():
        if f.filename == path:
            return Content(f)
github3.gists.Gist.contents = _gist_contents
def _iter_gist_forks(self):
    for fork in self._iter_forks():
        fork['files'] = []
        fork['owner'] = fork['user']
        fork['html_url'] = 'https://gist.github.com/%s/%s' % (fork['user']['login'], fork['id'])
        yield github3.gists.Gist(fork)
github3.gists.Gist._iter_forks = github3.gists.Gist.iter_forks
github3.gists.Gist.iter_forks = _iter_gist_forks

def main():
    usage = """github integration for git
A full manual can be found on http://seveas.github.com/git-hub

Usage:
  git-hub add-hook <name> [<setting>...]
  git-hub add-public-keys [<key>...]
  git-hub add-remote [--ssh|--http] <user>
  git-hub apply-pr <pr-number>
  git-hub browse [--parent]
  git-hub calendar [<user>]
  git-hub cat <file>...
  git-hub clone [--ssh|--http] <repo>
  git-hub create [--private] [-d <description>]
  git-hub edit-hook <name> [<setting>...]
  git-hub fork [--ssh|--http] [<repo>]
  git-hub forks
  git-hub gist [--desc <description>] <file>...
  git-hub gists [<user>]
  git-hub hooks
  git-hub ignore [<language>...]
  git-hub issue [--parent] [<issue>...]
  git-hub issues [--parent] [<filter>...]
  git-hub log [--type=<type>] [<what>]
  git-hub mirror [--ssh|--http] [--goblet] [<repo>]
  git-hub network [<level>]
  git-hub public-keys <user>
  git-hub pull-request [--issue=<issue>] [<branch1:branch2>]
  git-hub remove-hook <name>
  git-hub render <file>
  git-hub repos [--no-forks] [<user>]
  git-hub run-shell
  git-hub say [<msg>]
  git-hub set-origin [--ssh|--http]
  git-hub status
  git-hub whoami
  git-hub whois <user>...

Options:
  -h --help              Show this help message and exit
  --desc=<description>   Description for the new gist/repo
  --parent               Show issues for the parent repo
  --issue=<issue>        Turn this issue into a pull request
  --ssh                  Use SSH for cloning 3rd party repos
  --http                 Use https for cloning 3rd party repos
  --goblet               When mirroring, set up goblet configuration
"""

    opts = docopt.docopt(usage)
    for command in commands:
        if opts[command]:
            try:
                commands[command](opts)
            except KeyboardInterrupt:
                sys.exit(1)
            break

def err(msg):
    sys.stderr.write(msg + "\n")
    sys.exit(1)

def check(result, must_succeed=True):
    if result.returncode != 0 and must_succeed:
        print(result.stderr.rstrip())
        sys.exit(result.returncode)
    return result

commands = {}
def command(fnc):
    commands[fnc.__name__.replace('_','-')] = fnc
    return fnc

def github():
    gh = github3.GitHub()

    config_file = os.path.join(os.path.expanduser('~'), '.githubconfig')
    old_umask = os.umask(63) # 0o077

    user = shell.git('config', '--file', config_file, 'github.user').stdout.strip()
    if not user:
        user = raw_input("Github user: ").strip()
        shell.git('config', '--file', config_file, 'github.user', user)

    token = shell.git('config', '--file', config_file, 'github.token').stdout.strip()
    if not token:
        def prompt_for_2fa():
            """Callback for github3.py's 2FA support."""
            return raw_input("Two-Factor Authentication Code: ").strip()
        password = getpass.getpass("GitHub password: ")
        # The extra gh object is needed for possible two-factor authentication to avoid the
        # main gh object having a username/password and thus getting into a 2fa loop
        gh2 = github3.GitHub()
        gh2.login(user, password, two_factor_callback=prompt_for_2fa)
        try:
            auth = gh2.authorize(user, password, ['user', 'repo', 'gist'],
                    "Github Git integration on %s" % socket.gethostname(), "http://seveas.github.com/git-hub")
        except github3.GitHubError:
            type, exc, tb = sys.exc_info()
            if hasattr(exc, 'response'):
                response = exc.response
                if response.status_code == 422:
                    for error in response.json()['errors']:
                        if error['resource'] == 'OauthAccess' and error['code'] == 'already_exists':
                            err("An OAuth token for this host already exists, please delete it on https://github.com/settings/applications")
            raise type.with_traceback(tb)
        token = auth.token
        shell.git('config', '--file', config_file, 'github.token', token)
        shell.git('config', '--file', config_file, 'github.auth_id', str(auth.id))
        print("A GitHub authentication token is now cached in ~/.githubconfig - do not share this file")
        print("To revoke access, visit https://github.com/settings/applications")

    if not user or not token:
        err("No user or token specified")
    gh.login(username=user, token=token)
    try:
        gh.user()
    except github3.GitHubError:
        # Token obsolete
        shell.git('config', '--file', config_file, '--unset', 'github.token')
        gh = github()
    os.umask(old_umask)
    return gh

def get_repo(must_be_in_repo=True):
    # Find the repo on github by searching for remotes hosted on github in the
    # following order
    # - A remote owned by the current user
    # - A remote named 'origin'
    # - A remote named 'upstream'
    # - The first defined remote
    # - A repository on github with the same name as the current directory
    gh = github()
    me = gh.user().login
    mine = origin = upstream = repo = None
    if not check(shell.git('rev-parse', '--git-dir'), must_be_in_repo):
        return
    remotes = shell.git('config', '--get-regexp', 'remote\..*\.url', 'github.com').stdout.strip().splitlines()
    for remote in reversed(remotes):
        m = re.match('^remote\.([^.]*)\.url.*?(gist.)?github.com[/:](?:([^/]*)/)?([^/]*?)(?:\.git)?$', remote)
        remote, gist, user, repo = m.groups()
        if gist:
            repo = gh.gist(repo)
            user = repo.owner.login
        else:
            repo = gh.repository(user, repo)
            if not repo:
                print("Repository %s/%s no longer exists on github" % m.groups()[2:])
                continue
        repo.remote = remote
        if remote == 'origin':
            origin = repo
        elif remote == 'upstream':
            upstream = repo
        if user == me:
            mine = repo
    repo = mine or origin or upstream or repo
    if not repo:
        repo = os.path.basename(shell.git('rev-parse', '--show-toplevel').stdout.strip())
        repo = gh.repository(me, repo)
    return repo

@command
def create(opts):
    """Create a repository on github to push to"""
    root = check(shell.git('rev-parse', '--show-toplevel')).stdout.strip()
    name = os.path.basename(root)
    gh = github()
    if name in [x.name for x in gh.iter_repos()]:
        err("Repository already exists")
    gh.create_repo(name=name, description=opts['<description>'] or "", private=opts['--private'])
    set_origin(opts)

@command
def set_origin(opts):
    """Set the remote 'origin' to github.\n  If this is a fork, set the remote 'upstream' to the parent"""
    gh = github()
    me = gh.user()
    repo = get_repo()
    # Is this mine? No? Do I have a clone?
    if repo.owner.login != me.login:
        my_repo = gh.repository(me, repo.name)
        if my_repo:
            repo = my_repo

    if shell.git('config', 'remote.origin.url').stdout.strip() != repo.ssh_url:
        print("Pointing origin to %s" % repo.ssh_url)
        shell.git('config', 'remote.origin.url', repo.ssh_url)
    shell.git('config', '--replace-all', 'remote.origin.fetch', '+refs/heads/*:refs/remotes/origin/*')

    if repo.fork:
        parent = repo.parent
        url = parent.git_url
        if opts['--ssh'] or parent.private:
            url = parent.ssh_url
        elif opts['--http']:
            url = parent.clone_url
        if shell.git('config', 'remote.upstream.url').stdout.strip() != url:
            print("Pointing upstream to %s" % url)
            shell.git('config', 'remote.upstream.url', url)
        shell.git('config', 'remote.upstream.fetch', '+refs/heads/*:refs/remotes/upstream/*')
    else:
        # If issues are enabled, fetch pull requests
        try:
            list(repo.iter_issues(number=1))
        except github3.GitHubError:
            pass
        else:
            shell.git('config', '--add', 'remote.origin.fetch', '+refs/pull/*/head:refs/pull/*/head')

    for branch in shell.git('for-each-ref', 'refs/heads/**').stdout.strip().splitlines():
        branch = branch.split(None, 2)[-1][11:]
        if shell.git('for-each-ref', 'refs/remotes/origin/%s' % branch).stdout.strip():
            if shell.git('config', 'branch.%s.remote' % branch).returncode != 0:
                print("Marking %s as remote-tracking branch" % branch)
                shell.git('config', 'branch.%s.remote' % branch, 'origin')
                shell.git('config', 'branch.%s.merge' % branch, 'refs/heads/%s' % branch)

@command
def repos(opts):
    """[user] List all repos of a user, by default yours"""
    gh = github()
    if opts['<user>']:
        repos = list(gh.iter_user_repos(opts['<user>'][0], type='all'))
    else:
        repos = list(gh.iter_repos(type='all'))
        opts['<user>'] = [gh.user().login]
    maxlen = max([len(x.name) for x in repos])
    # XXX github3.py PR 193
    # maxstar = len(str(max([x.stargazers for x in repos])))
    maxstar = len(str(max([x._json_data['stargazers_count'] for x in repos])))
    maxfork = len(str(max([x.forks for x in repos])))
    maxwatch = len(str(max([x.watchers for x in repos])))
    # XXX github support request filed: watchers is actually stars
    #fmt = u"%%-%ds \u2605 %%-%ds \u25c9 %%-%ds \u2919 %%-%ds %%s" % (maxlen, maxstar, maxwatch, maxfork)
    fmt = u"%%-%ds \u2605 %%-%ds \u2919 %%-%ds %%s" % (maxlen, maxstar, maxfork)
    for repo in repos:
        color = [attr.normal]
        if repo.private:
            color.append(fgcolor.red)
        if repo.fork:
            if opts['--no-forks']:
                continue
            color.append(attr.faint)
        name = repo.name
        if opts['<user>'][0] != repo.owner.login:
            name = '%s/%s' % (repo.owner.login, name)
        msg = wrap(fmt % (name, repo._json_data['stargazers_count'], repo.forks, repo.description), *color)
        if not PY3:
            msg = msg.encode('utf-8')
        print(msg)

@command
def clone(opts):
    """Clone a repository by name"""
    gh = github()
    if '/' in opts['<repo>']:
        if 'gist.github.com' in opts['<repo>']:
            user, repo = 'gist', opts['<repo>'].rsplit('/',1)[-1]
        else:
            user, repo = opts['<repo>'].rsplit('/',2)[-2:]
    else:
        user, repo = gh.user().login, opts['<repo>']
    if repo.endswith('.git'):
        repo = repo[:-4]

    if user == 'gist':
        # This is a gist, not a normal repo
        repo_ = gh.gist(repo)
        if not repo_:
            err("Gist %s does not exist" % repo)
        user = repo_.owner.login
    else:
        repo_ = gh.repository(user, repo)
        if not repo_:
            err("Repository %s/%s does not exist" % (user, repo))
    repo = repo_
    url = repo.ssh_url
    if gh.user().login != user:
        url = repo.git_url
    if opts['--ssh'] or repo.private:
        url = repo.ssh_url
    elif opts['--http']:
        url = repo.clone_url

    rc = shell.git('clone', url, redirect=False).returncode
    if rc:
        sys.exit(rc)
    if repo.fork:
        os.chdir(repo.name)
        set_origin(opts)
        shell.git('fetch', 'upstream', redirect=False)

@command
def mirror(opts):
    gh = github()
    if opts['<repo>']:
        if '/' in opts['<repo>']:
            user, repo = opts['<repo>'].rsplit('/',2)[-2:]
        else:
            user, repo = gh.user().login, opts['<repo>']
        if repo.endswith('.git'):
            repo = repo[:-4]
        git_dir = repo + '.git'
        if repo == '*':
            for repo in gh.iter_user_repos(user):
                opts['<repo>'] = '%s/%s' % (user, repo)
                mirror(opts)
            for repo in gh.iter_gists(user):
                opts['<repo>'] = 'gist/%s' % repo.name
                mirror(opts)
            return
        if user == 'gist':
            repo_ = gh.gist(repo)
            if not repo_:
                err("Gist %s does not exist" % repo)
        else:
            repo_ = gh.repository(user, repo)
            if not repo_:
                err("Repository %s/%s does not exist" % (user, repo))
    else:
        git_dir = '.'
        repo_ = get_repo()
        if not repo_:
            err("Repository %s/%s does not exist" % (user, repo))
    repo = repo_

    if not os.path.exists(git_dir):
        url = repo.git_url
        if opts['--ssh'] or repo.private:
            url = repo.ssh_url
        elif opts['--http']:
            url = repo.clone_url

        rc = shell.git('clone', '--mirror', url, redirect=False).returncode
        if rc:
            sys.exit(rc)

    else:
        # Update the current, mirrored repo
        if shell.git('--git-dir', git_dir, 'config', 'core.bare').stdout.strip() != 'true' or \
           shell.git('--git-dir', git_dir, 'config', 'remote.origin.mirror').stdout.strip() != 'true':
               err("This is not a mirrored repository")
        rc = shell.git('--git-dir', git_dir, 'fetch', '-q', 'origin', redirect=False).returncode
        if rc:
            sys.exit(rc)
        shell.git('--git-dir', git_dir, 'remote', 'prune', 'origin', redirect=False).returncode
        if rc:
            sys.exit(rc)

    with open(os.path.join(git_dir, 'description'), 'w') as fd:
        if PY3:
            fd.write(repo.description)
        else:
            fd.write(repo.description.encode('utf-8'))
    if opts['--goblet']:
        if repo.fork:
            owner = gh.user(repo.parent.owner.login)
        else:
            owner = gh.user(repo.owner.login)
        shell.git('--git-dir', git_dir, 'config', 'goblet.owner', owner.name.encode('utf-8') or owner.login)
        shell.git('--git-dir', git_dir, 'config', 'goblet.cloneurlgit', repo.git_url)
        shell.git('--git-dir', git_dir, 'config', 'goblet.cloneurlhttp', repo.clone_url)
        goblet_dir = os.path.join(git_dir, 'goblet')
        if not os.path.exists(goblet_dir):
            os.mkdir(goblet_dir, 0o777)
            os.chmod(goblet_dir, 0o777)

@command
def fork(opts):
    """Fork a repo and clone it"""
    gh = github()
    me = gh.user()
    repo_ = None
    if not opts['<repo>']:
        repo_ = get_repo()
        if isinstance(repo_, github3.gists.Gist):
            user, repo = 'gist', repo_.name
        else:
            user, repo = repo_.owner.login, repo_.name
        do_clone = False
    else:
        if '/' not in opts['<repo>']:
            err("Usage: git hub fork url\n       git hub fork user/repo")
        if 'gist.github.com' in opts['<repo>']:
            user, repo = 'gist', opts['<repo>'].rsplit('/',1)[-1]
        else:
            user, repo = opts['<repo>'].rsplit('/',2)[-2:]
        if user == 'gist':
            repo_ = gh.gist(repo)
            if not repo_:
                err("Gist %s does not exist" % repo)
        else:
            repo_ = gh.repository(user, repo)
            if not repo_:
                err("Repository %s/%s does not exist" % (user, repo))
        do_clone = True

    if repo.endswith('.git'):
        repo = repo[:-4]

    if user == 'gist':
        for fork in repo_.iter_forks():
            if fork.owner.login == me.login:
                err("You already forked this gist as %s" % fork.html_url)
    else:
        if repo in [x.name for x in gh.iter_repos() if x.owner.login == me.login]:
            err("Repository already exists")

    my_clone = repo_.create_fork()
    if user == 'gist':
        opts['<repo>'] = 'gist/%s' % my_clone.name
    else:
        opts['<repo>'] = my_clone.name

    if do_clone:
        clone(opts)
    else:
        set_origin(opts)

@command
def forks(opts):
    """List all forks of this repository"""
    repo = get_repo()
    if repo.fork:
        repo = repo.parent
    print("[%s] %s" % (wrap(repo.owner.login, attr.bright), repo.html_url))
    for fork in repo.iter_forks():
        print("[%s] %s" % (fork.owner.login, fork.html_url))

@command
def issues(opts):
    """List issues"""
    repo = get_repo(False)
    if not repo:
        repos = list(github().iter_repos(type='all'))
    else:
        repos = [repo]
    for repo in repos:
        if repo.fork and opts['--parent']:
            repo = repo.parent
        filters = dict([x.split('=', 1) for x in opts['<filter>']])
        try:
            issues = list(repo.iter_issues(**filters))
        except github3.GitHubError:
            _, err, _ = sys.exc_info()
            if err.code == 410:
                if len(repos) == 1:
                    print(err.message)
                continue
            else:
                raise
        if not issues:
            continue
        print(wrap("Issues for %s/%s" % (repo.owner.login, repo.name), attr.bright))
        for issue in issues:
            url = issue.pull_request and issue.pull_request['html_url'] or issue.html_url
            print("[%d] %s %s" % (issue.number, issue.title, url))

@command
def issue(opts):
    """Issue details"""
    repo = get_repo()
    if repo.fork and opts['--parent']:
        repo = repo.parent
    for issue in opts['<issue>']:
        issue = repo.issue(issue)
        print(wrap(issue.title, attr.bright, attr.underline))
        print(issue.body)
        print(issue.pull_request and issue.pull_request['html_url'] or issue.html_url)
    if not opts['<issue>']:
        body = """
# Reporting an issue on %s/%s
# Please describe the issue as clarly as possible. Lines starting with '#' will
# be ignored, the first line will be used as title for the issue.
#""" % (repo.owner.login, repo.name)
        title, body = edit_msg(body, 'ISSUE_EDITMSG')
        if not body:
            err("Empty issue message")

        issue = repo.create_issue(title=title, body=body)
        print("Issue %d created %s" % (issue.number, issue.html_url))

@command
def add_remote(opts):
    """Add user's fork as a remote by that name"""
    repo = get_repo()
    if repo.fork:
        repo = repo.parent
    forks = repo.iter_forks()
    for fork in forks:
        if fork.owner.login in opts['<user>']:
            url = fork.git_url
            if opts['--ssh'] or fork.private:
                url = fork.ssh_url
            elif opts['--http']:
                url = fork.clone_url
            check(shell.git('remote', 'add', fork.owner.login, url))
            check(shell.git('fetch', fork.owner.login, stdout=False, stderr=False))

@command
def whois(opts):
    """Display github user info"""
    gh = github()
    for user_ in opts['<user>']:
        user = gh.user(user_)
        if not user:
            print("No such user: %s" % user_)
            continue
        print(wrap(user.name or user.login, attr.bright, attr.underline))
        print('Profile   %s' % user.html_url)
        if user.email:
            print('Email     %s' % user.email)
        if user.blog:
            print('Blog      %s' % user.blog)
        if user.location:
            print('Location  %s' % user.location)
        if user.company:
            print('Company   %s' % user.company)
        print('Repos     %d public, %d private' % (user.public_repos, user.total_private_repos))
        print('Gists     %d public, %d private' % (user.public_gists, user.total_private_gists))
        if user.login == gh.user().login:
            keys = gh.iter_keys()
        else:
            keys = user.iter_keys()
        for pkey in keys:
            algo, key = pkey.key.split()
            algo = algo[4:].upper()
            if pkey.title:
                print("%s key%s...%s (%s)" % (algo, ' ' * (6 - len(algo)), key[-10:], pkey.title))
            else:
                print("%s key%s...%s" % (algo, ' ' * (6 - len(algo)), key[-10:]))
        # XXX User.iter_orgs is not yet in a released version of github3.py.
        # Remove check when released and dependencies updated
        if hasattr(user, 'iter_orgs'):
            orgs = list(user.iter_orgs())
            if orgs:
                print("Member of %s" % ', '.join([x.login for x in orgs]))

@command
def whoami(opts):
    """Display github user info"""
    gh = github()
    opts['<user>'] = [gh.user().login]
    whois(opts)

@command
def gist(opts):
    """Create a new gist from files"""
    files = {}
    description = opts['<description>'] or ''
    for f in opts['<file>']:
        if f == '-':
            files['stdout'] = {'content': sys.stdin.read()}
        else:
            if not os.path.exists(f):
                err("No such file: %s" % f)
            with open(f) as fd:
                files[os.path.basename(f)] = {'content': fd.read()}
    gist = github().create_gist(description=description, files=files)
    print("Gist created at %s" % gist.html_url)

@command
def gists(opts):
    gh = github()
    user = (opts['<user>'] or [gh.user().login])[0]
    for gist in gh.iter_gists(user):
        print("%s - %s" % (gist.html_url, gist.description))

@command
def add_public_keys(opts):
    """Adds keys to your public keys"""
    if not opts['<key>']:
        opts['<key>'] = glob.glob(os.path.join(os.path.expanduser('~'), '.ssh', 'id_*.pub'))
    gh = github()
    existing = [x.key for x in gh.iter_keys()]
    for arg in opts['<key>']:
        with open(arg) as fd:
            algo, key, title = fd.read().strip().split(None, 2)
        key = "%s %s" % (algo, key)
        if key in existing:
            continue
        print("Adding %s" % arg)
        gh.create_key(title=title, key=key)

@command
def public_keys(opts):
    """Lists all keys for a user"""
    gh = github()
    if gh.user().login == opts['<user>'][0]:
        keys = gh.iter_keys()
    else:
        keys = gh.user(opts['<user>'][0]).iter_keys()
    for key in keys:
        print("%s %s" % (key.key, key.title or ''))

@command
def pull_request(opts):
    """Opens a pull request to merge your branch1 to upstream branch2"""
    repo = get_repo()
    if repo.fork:
        parent = repo.parent
    else:
        parent = repo
    # Which branch?
    src = opts['<branch1:branch2>'] or ''
    dst = None
    if ':' in src:
        src, dst = src.split(':', 1)
    if not src:
        src = check(shell.git('rev-parse', '--abbrev-ref', 'HEAD')).stdout.strip()
    if not dst:
        dst = 'master'

    if src == dst and parent == repo:
        err("Cannot file a pull request on the same branch")

    # Try to get the local commit
    commit = check(shell.git('show-ref', 'refs/heads/%s' % src)).stdout.split()[0]
    # Do they exist on github?
    srcb = repo.branch(src)
    if not srcb:
        if raw_input("Branch %s does not exist in your github repo, shall I push? [Y/n] " % src).lower() in ['y', 'Y', '']:
            shell.git('push', repo.remote, src)
        else:
            err("Aborting")
    elif srcb and srcb.commit.sha != commit:
        # Have we diverged? Then there are commits that are reachable from the github branch but not local
        diverged = shell.git('rev-list', srcb.commit.sha, '^' + commit)
        if diverged.stderr or diverged.stdout:
            if raw_input("Branch %s has diverged from github, shall I push and overwrite? [y/N] " % src) in ['y', 'Y']:
                shell.git('push', '--force', repo.remote, src)
            else:
                err("Aborting")
        else:
            if raw_input("Branch %s not up to date on github, but can be fast forwarded, shall I push? [Y/n] " % src) in ['y', 'Y', '']:
                shell.git('push', repo.remote, src)
            else:
                err("Aborting")

    dstb = parent.branch(dst)
    if not dstb:
        err("Branch %s does not exist in %s/%s" % (dst, parent.owner.login, parent.name))

    # Do we have the dst locally?
    for remote in check(shell.git('remote')).stdout.strip().split("\n"):
        url = check(shell.git('config', 'remote.%s.url' % remote)).stdout.strip()
        if url in [parent.git_url, parent.ssh_url, parent.clone_url]:
            if parent.private and url != parent.ssh_url:
                err("You should configure %s/%s to fetch via ssh, it is a private repo" % (parent.owner.login, parent.name))
            check(shell.git('fetch', remote))
            break
    else:
        err("You don't have %s/%s configured as a remote repository" % (parent.owner.login, parent.name))

    # How many commits?
    commits = try_decode(check(shell.git('log', '--pretty=%H', '%s/%s..%s' % (remote, dst, src))).stdout).strip().split()
    commits.reverse()
    # 1: title/body from commit
    if not commits:
        err("Your branch has no commits yet")
    # Are we turning an issue into a commit?
    if opts['--issue']:
        pull = parent.create_pull_from_issue(base=dst, head='%s:%s' % (repo.owner.login, src), issue=int(opts['--issue']))
        print("Pull request %d created %s" % (pull.number, pull.html_url))
        return
    if len(commits) == 1:
        title, body = check(shell.git('log', '--pretty=%s\n%b', '%s^..%s' % (commits[0], commits[0]))).stdout.split('\n', 1)
        title = title.strip()
        body = body.strip()

    # More: title from branchname (titlecased, s/-/ /g), body comments from shortlog
    else:
        title = src
        if '/' in title:
            title = title[title.rfind('/') + 1:]
        title = title.title().replace('-', ' ')
        body = ""

    body += """
# Requesting a pull from %s/%s into %s/%s
#
# Please enter a message to accompany your pull request. Lines starting
# with '#' will be ignored, and an empty message aborts the request.
#""" % (repo.owner.login, src, parent.owner.login, dst)
    body += "\n# " + try_decode(check(shell.git('shortlog', '%s/%s..%s' % (remote, dst, src))).stdout).strip().replace('\n', '\n# ')
    body += "\n#\n# " + try_decode(check(shell.git('diff', '--stat', '%s^..%s' % (commits[0], commits[-1]))).stdout).strip().replace('\n', '\n#')
    title, body = edit_msg("%s\n\n%s" % (title,body), 'PULL_REQUEST_EDIT_MSG')
    if not body:
        err("No pull request message specified")

    pull = parent.create_pull(base=dst, head='%s:%s' % (repo.owner.login, src), title=title, body=body)
    print("Pull request %d created %s" % (pull.number, pull.html_url))

def edit_msg(msg, filename):
    temp_file = os.path.join(check(shell.git('rev-parse', '--git-dir')).stdout.strip(), filename)
    with open(temp_file, 'w') as fd:
        fd.write(msg.encode('utf-8'))
    editor = shlex.split(check(shell.git('var', 'GIT_EDITOR')).stdout) + [temp_file]
    shell[editor[0]](*editor[1:], redirect=False)
    with open(temp_file) as fd:
        title, body = (try_decode(fd.read()) +'\n').split('\n', 1)
    title = title.strip()
    body = body.strip()
    body = re.sub('^#.*', '', body, flags=re.MULTILINE).strip()
    return title, body

@command
def apply_pr(opts):
    gh = github()
    repo = get_repo()
    pr = repo.pull_request(opts['<pr-number>'])
    if not pr:
        err("Pull request %s does not exist" % opts['<pr-number>'])
    print("Applying PR#%d from %s: %s" % (pr.number, gh.user(pr.user).name, pr.title))
    # Warnings
    warned = False
    cbr = shell.git('rev-parse', '--symbolic-full-name', 'HEAD').stdout.strip().replace('refs/heads/','')
    if cbr != pr.base.ref:
        print(wrap("Pull request was filed against %s, but you're on the %s branch" % (pr.base.ref, cbr), fgcolor.red))
        warned = True
    if pr.merged_at:
        print(wrap("Pull request was already merged at %s by %s" % (pr.merged_at, pr.merged_by), fgcolor.red))
    if not pr.mergeable or pr.mergeable_state != 'clean':
        print(wrap("Pull request will not apply cleanly", fgcolor.red))
        warned = True
    if pr.state == 'closed':
        print(wrap("Pull request has already been closed", fgcolor.red))
        warned = True
    if warned:
        if raw_input("Continue? [y/N] ") not in ['y', 'Y']:
            sys.exit(1)
    # Fetch PR if needed
    sha = shell.git('rev-parse', '--verify', 'refs/pull/%d/head' % pr.number).stdout.strip()
    if sha != pr.head.sha:
        print("Fetching pull request")
        url = gh.repository(pr.repository[0].replace('repos/', ''), pr.repository[1]).clone_url
        shell.git('fetch', url, 'refs/pull/%d/head:refs/pull/%d/head' % (pr.number, pr.number), redirect=False)
    print("Cherry-picking %d commit(s): %s..refs/pull/%d/head" % (pr.commits, pr.base.ref, pr.number))
    shell.git('cherry-pick', '%s..refs/pull/%d/head' % (pr.base.ref, pr.number), redirect=False)

@command
def network(opts):
    """Create a graphviz graph of followers and forks"""
    from collections import defaultdict
    class P:
        def __init__(self, user):
            self.user = user
            self.done = False
            self.rel_to = defaultdict(list)

        def __repr__(self):
            return dict.__repr__(self.rel_to)

    level = 1
    if opts['<level>']:
        try:
            level = int(opts['<level>'])
        except ValueError:
            err("Integer argument required")
    gh = github()
    me = gh.user()
    people = {me.login: P(me)}
    for i in range(level):
        for login, person in list(people.items()):
            if person.done:
                continue

            sys.stderr.write("Looking at user %s\n" % login)
            # Followers
            for other in person.user.iter_followers():
                if other.login not in people:
                    people[other.login] = P(other)
                people[other.login].rel_to[login].append('follows')
            for other in person.user.iter_following():
                if other.login not in people:
                    people[other.login] = P(other)
                person.rel_to[other.login].append('follows')

            # Forks
            for repo in gh.iter_user_repos(login, type='owner'):
                sys.stderr.write("Looking at repo %s\n" % repo.name)
                if repo.fork:
                    # Sigh. GH doesn't return parent info in iter_repos
                    repo = gh.repository(repo.owner.login, repo.name)
                    if repo.owner.login not in people:
                        people[repo.owner.login] = P(repo.owner)
                    person.rel_to[repo.parent.owner.login].append('forked %s' % repo.parent.name)
                else:
                    for fork in repo.iter_forks():
                        if fork.owner.login == login:
                            continue
                        if fork.owner.login not in people:
                            people[fork.owner.login] = P(fork.owner)
                        people[fork.owner.login].rel_to[login].append('forked %s' % repo.name)
            person.done = True

    # Now we create a graph
    graph = ["digraph network {"]
    for person in people:
        graph.append('    "%s"' % person)

    for login, person in people.items():
        for other, types in person.rel_to.items():
            graph.append('    "%s" -> "%s" [label="%s"]' % (login, other, "\\n".join(types)))

    graph.append("}")
    print("\n".join(graph))

@command
def hooks(opts):
    repo = get_repo()
    for hook in repo.iter_hooks():
        print(wrap("%s (%s)" % (hook.name, ', '.join(hook.events)), attr.bright))
        for key, val in sorted(hook.config.items()):
            if val in (None, ''):
                continue
            print("  %s: %s" % (key, val))

@command
def remove_hook(opts):
    repo = get_repo()
    for hook in repo.iter_hooks():
        if hook.name == opts['<name>']:
            hook.delete()

@command
def add_hook(opts):
    repo = get_repo()
    for hook in repo.iter_hooks():
        if hook.name == opts['<name>']:
            raise ValueError("Hook %s already exists" % opts['<name>'])
    settings = dict([x.split('=', 1) for x in opts['<setting>']])
    for key in settings:
        if settings[key].isdigit():
            settings[key] = int(settings[key])
    events = settings.pop('events', 'push').split(',')
    repo.create_hook(opts['<name>'], settings, events)

@command
def edit_hook(opts):
    repo = get_repo()
    for hook in repo.iter_hooks():
        if hook.name == opts['<name>']:
            break
    else:
        raise ValueError("Hook %s does not exist" % opts['<name>'])

    settings = dict([x.split('=', 1) for x in opts['<setting>']])
    for key in settings:
        if settings[key].isdigit():
            settings[key] = int(settings[key])
    events = settings.pop('events', ','.join(hook.events)).split(',')
    config = hook.config
    config.update(settings)
    hook.edit(opts['<name>'], config, events)

@command
def ignore(opts):
    lang = opts['<language>']
    gh = github()
    if not lang:
        langs = sorted(gh.gitignore_templates(), key = lambda x: x.lower())
        print("Languages for which a gitignore template is available:\n  * " + "\n  * ".join(langs))
    else:
        for l in lang:
            print("# Ignore patterns for " + l)
            print(gh.gitignore_template(l).strip())

@command
def browse(opts):
    """Open the GitHub page for this repo in a browser"""
    repo = get_repo()
    if repo.fork and opts['--parent']:
        repo = repo.parent
    webbrowser.open_new(repo.html_url)

@command
def cat(opts):
    """Display the contents of a file on github"""
    gh = github()
    for file in opts['<file>']:
        repo, ref, file = ([None, None] + file.split(':',2))[-3:]
        user = None
        if repo:
            user, repo = ([None] + repo.split('/'))[-2:]
        repo = gh.repository(user or gh.user().login, repo) if repo else get_repo()
        content = repo.contents(path=file, ref=ref)
        if content:
            print(content.decoded)
        else:
            sys.stderr.write("No such file: %s\n" % file)

@command
def render(opts):
    with open(opts['<file>'][0]) as fd:
        data = fd.read()
    html = github3.markdown(data)
    with tempfile.NamedTemporaryFile(suffix='.html') as fd:
        fd.write(html)
        fd.flush()
        webbrowser.open('file://' + fd.name)
        time.sleep(1)

@command
def log(opts):
    """Display github log for yourself or other users"""
    gh = github()
    logtype = 'user'
    if not opts['<what>']:
        what = gh.user()
    else:
        if '/' in opts['<what>']:
            logtype = 'repo'
            user, repo = opts['<what>'].split('/', 1)
            if user == 'gist':
                what = gh.gist(repo)
                if not what:
                    err("Gist %s does not exist" % repo)
            else:
                what = gh.repository(user, repo)
                if not what:
                    err("Repository %s/%s does not exist" % (user, repo))
        else:
            what = gh.user(opts['<what>'])
            if not what:
                err("User %s does not exist" % opts['<what>'])

    if not opts['--type']:
        events = [x for x in what.iter_events(number=30)]
    else:
        events = []
        etype = opts['--type'].lower() + 'event'
        for event in what.iter_events(number=300):
            if event.type.lower() == etype:
                events.append(event)
                if len(events) == 30:
                    break

    now = datetime.datetime.now()
    for event in reversed(events):
        ts = event.created_at
        if ts.year == now.year:
            if (ts.month, ts.day) == (now.month, now.day):
                ts = wrap(ts.strftime("%H:%M"), attr.faint)
            else:
                ts = wrap(ts.strftime("%m/%d %H:%M"), attr.faint)
        else:
            ts = wrap(ts.strftime("%Y/%m/%d %H:%M"), attr.faint)
        repo = '/'.join(event.repo)
        repo_ = ' (%s)' % repo
        if logtype == 'repo':
            repo_ = ''
            ts += ' %s' % event.actor.login
        if event.type == 'CommitCommentEvent':
            print("%s commented on commit %s%s" % (ts, event.payload['comment'].commit_id[:7], repo_))
        elif event.type == 'CreateEvent':
            if event.payload['ref_type'] == 'repository':
                print("%s created %s %s" % (ts, event.payload['ref_type'], repo))
            else:
                print("%s created %s %s%s" % (ts, event.payload['ref_type'], event.payload['ref'], repo_))
        elif event.type == 'DeleteEvent':
            print("%s deleted %s %s%s" % (ts, event.payload['ref_type'], event.payload['ref'], repo_))
        elif event.type == 'DownloadEvent':
            print("%s created download %s (%s)" % (ts, event.payload['name'], event.payload['description']))
        elif event.type == 'FollowEvent':
            print("%s started following %s" % (ts, event.payload['target'].login))
        elif event.type == 'ForkEvent':
            print("%s forked %s to %s/%s" % (ts, repo, event.payload['forkee'].owner.login, event.payload['forkee'].name))
        elif event.type == 'ForkApplyEvent':
            print("%s applied %s to %s%s" % (ts, event.payload['after'][:7], event.payload['head'], repo_))
        elif event.type == 'GistEvent':
            print("%s %sd gist #%s" % (ts, event.payload['action'], event.payload['gist'].html_url))
        elif event.type == 'GollumEvent':
            pages = len(event.payload['pages'])
            print("%s updated %d wikipage%s%s" % (ts, pages, {1:''}.get(pages, 's'), repo_))
        elif event.type == 'IssueCommentEvent':
            print("%s commented on issue #%s%s" % (ts, event.payload['issue'].number, repo_))
        elif event.type == 'IssuesEvent':
            print("%s %s issue #%s%s" % (ts, event.payload['action'], event.payload['issue'].number, repo_))
        elif event.type == 'MemberEvent':
            print("%s %s %s to %s" % (ts, event.payload['action'], event.payload['member'].login, repo))
        elif event.type == 'PublicEvent':
            print("%s made %s open source" % repo)
        elif event.type == 'PullRequestReviewCommentEvent':
            print("%s commented on a pull request for commit %s%s" % (ts, event.payload['comment'].commit_id[:7], repo_))
        elif event.type == 'PullRequestEvent':
            print("%s %s pull_request #%s%s" % (ts, event.payload['action'], event.payload['pull_request'].number, repo_))
        elif event.type == 'PushEvent':
            # Old push events have shas and not commits
            if 'commits' in event.payload:
                commits = len(event.payload['commits'])
            else:
                commits = len(event.payload['shas'])
            print("%s pushed %d commits to %s%s" % (ts, commits, event.payload['ref'][11:], repo_))
        elif event.type == 'ReleaseEvent':
            print("%s released %s" % (ts, event.payload['name']))
        elif event.type == 'StatusEvent':
            print("%s commit %s changed to %s" % (ts, event.payload['sha'][:7], event.payload['state']))
        elif event.type == 'TeamAddEvent':
            what = event.payload['user'] or event.payload['repository']
            print("%s %s %s was added to team %s" % (ts, what.__class__.lower(), what.name, event.payload['team'].name))
        elif event.type == 'WatchEvent':
            print("%s %s watching %s" % (ts, event.payload['action'], repo))
        elif event.type == 'GistHistoryEvent':
            print("%s committed %s additions, %s deletions" % (ts, event.additions, event.deletions))
        else:
            from pprint import pprint
            print(wrap("Cannot display %s. Please file a bug at github.com/seveas/git-hub\nincluding the following output:" % event.type, attr.bright))
            pprint(event.payload)

@command
def calendar(opts):
    """Show a timeline of a user's activity"""
    gh = github()
    user = (opts['<user>'] or [gh.user().login])[0]
    months = []
    rows = [[],[],[],[],[],[],[]]
    commits = []

    data = requests.get('https://github.com/users/%s/contributions' % user).json()
    y, m, d = [int(x) for x in data[0][0].split('-')]
    wd = (datetime.date(y,m,d).weekday()+1) % 7
    for i in range(wd):
        rows[i].append((None,None))
    if wd:
        months.append(m)
    for (date, count) in data:
        count = int(count)
        y, m, d = [int(x) for x in date.split('-')]
        wd = (datetime.date(y,m,d).weekday()+1) % 7
        rows[wd].append((d, count))
        if not wd:
            months.append(m)
        if count:
            commits.append(count)

    # Print months
    sys.stdout.write("  ")
    last = -1
    skip = months[2] != months[0]
    monthtext = ('', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')
    for month in months:
        if month != last:
            sys.stdout.write(monthtext[month] + ' ')
            skip = True
            last = month
        elif not skip:
            sys.stdout.write('  ')
        else:
            skip = False
    print("")

    # Print commits
    days = 'SMTWTFS'
    commits.sort()
    p5  = commits[int(round(len(commits) * 0.95))]
    p15 = commits[int(round(len(commits) * 0.85))]
    p35 = commits[int(round(len(commits) * 0.65))]
    blob1 = b'\xe2\x96\xa0'.decode('utf-8')
    blob2 = b'\xe2\x97\xbc'.decode('utf-8')
    for rnum, row in enumerate(rows):
        if rnum % 2:
            sys.stdout.write(days[rnum] + " ")
        else:
            sys.stdout.write("  ")
        for (day, count) in row:
            if count is None:
                color = attr.conceal
            elif count > p5:
                color = fgcolor.xterm(22)
            elif count > p15:
                color = fgcolor.xterm(28)
            elif count > p35:
                color = fgcolor.xterm(64)
            elif count:
                color = fgcolor.xterm(65)
            else:
                color = fgcolor.xterm(237)
            if day == 1:
                msg = wrap(blob2, attr.underline, color)
                if not PY3:
                    msg = msg.encode('utf-8')
                sys.stdout.write(msg)
            else:
                msg = wrap(blob1, color)
                if not PY3:
                    msg = msg.encode('utf-8')
                sys.stdout.write(msg)
            sys.stdout.write(' ')
        print("")

@command
def say(opts):
    print(github3.octocat(opts['<msg>'] or None))

@command
def status(opts):
    messages = github3.GitHubStatus().messages()
    for message in reversed(messages):
        ts = time.strptime(message['created_on'], '%Y-%m-%dT%H:%M:%SZ')
        offset = time.timezone
        if time.daylight:
            offset = time.altzone
        color = {'good': fgcolor.green, 'minor': fgcolor.yellow, 'major': fgcolor.red}[message['status']]
        ts = datetime.datetime(ts.tm_year, ts.tm_mon, ts.tm_mday, ts.tm_hour, ts.tm_min, ts.tm_sec) - datetime.timedelta(0,offset)
        print('%s %s %s' % (wrap(ts.strftime('%Y-%m-%d %H:%M'), attr.faint), wrap("%-5s" % message['status'], color), message['body']))

@command
def run_shell(opts):
    import code
    import readline
    import rlcompleter
    gh = github()

    data = dict([(x.__name__, x) for x in commands.values()])
    data.update({
        'github':  gh,
        'github3': github3,
        'me':      gh.user(),
        'opts':    opts,
        'repo':    get_repo(False),
        'shell':   shell,
    })
    readline.set_completer(rlcompleter.Completer(data).complete)
    readline.parse_and_bind("tab: complete")
    shl = code.InteractiveConsole(data)
    shl.interact()
    sys.exit(1)

main()
